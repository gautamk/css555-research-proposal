
@article{kaur_statistical_2013,
	title = {Statistical Comparison of Modelling Methods for Software Maintainability Prediction},
	volume = {23},
	issn = {02181940},
	url = {http://offcampus.lib.washington.edu/login?url=http://search.ebscohost.com/login.aspx?direct=true&db=bth&AN=91672707&site=ehost-live},
	doi = {10.1142/S0218194013500198},
	abstract = {The objective of this paper is statistical comparison of modelling methods for software maintainability prediction. The statistical comparison is performed by building software maintainability prediction models using 27 different regression and machine learning based algorithms. For this purpose, software metrics datasets of two different commercial object-oriented systems are used. These systems were developed using an object oriented programming language Ada. These systems are User Interface Management System ({UIMS}) and Quality Evaluation System ({QUES}). It is shown that different measures like {MMRE}, {RMSE}, Pred(0.25) and Pred(0.30) calculated on predicted values obtained from leave one out ({LOO}) cross validation produce very divergent results regarding accuracy of modelling methods. Therefore the 27 modelling methods are evaluated on the basis of statistical significance tests. The Friedman test is used to rank various modelling methods in terms of absolute residual error. Six out of the ten top ranked modelling methods are common to both {UIMS} and {QUES}. This indicates that modelling methods for software maintainability predicton are solid and scalable. After obtaining ranks, pair wise Wilcoxon Signed rank test is performed. Wilcoxon Sign rank test indicates that the top ranking method in {UIMS} data set is significantly superior to only four other modelling methods whereas the top tanking method in {QUES} data set is significantly superior to 11 other modelling methods. The performance of instance based learning algorithms - {IBk} and Kstar is comparable to modelling methods used in earlier studies.},
	pages = {743--774},
	number = {6},
	journaltitle = {International Journal of Software Engineering \& Knowledge Engineering},
	shortjournal = {International Journal of Software Engineering \& Knowledge Engineering},
	author = {Kaur, Arvinder and Kaur, Kamaldeep},
	urldate = {2016-01-17},
	date = {2013-08},
	keywords = {{ALGORITHMS}, {CORRELATION} (Statistics), {MACHINE} learning, machine learning, {MATHEMATICAL} models, {PREDICTION} models, {REGRESSION} analysis, significance tests, software maintainability prediction, software maintenance},
	file = {EBSCO Full Text:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/WDKX5STV/Kaur and Kaur - 2013 - Statistical Comparison of Modelling Methods for So.pdf:application/pdf}
}

@article{ahmed_machine_2013,
	title = {Machine learning approaches for predicting software maintainability: a fuzzy-based transparent model},
	volume = {7},
	issn = {1751-8806},
	doi = {10.1049/iet-sen.2013.0046},
	shorttitle = {Machine learning approaches for predicting software maintainability},
	abstract = {Software quality is one of the most important factors for assessing the global competitive position of any software company. Thus, the quantification of the quality parameters and integrating them into the quality models is very essential.Many attempts have been made to precisely quantify the software quality parameters using various models such as Boehm's Model, {McCall}'s Model and {ISO}/{IEC} 9126 Quality Model. A major challenge, although, is that effective quality models should consider two types of knowledge: imprecise linguistic knowledge from the experts and precise numerical knowledge from historical data.Incorporating the experts' knowledge poses a constraint on the quality model; the model has to be transparent.In this study, the authorspropose a process for developing fuzzy logic-based transparent quality prediction models.They applied the process to a case study where Mamdani fuzzy inference engine is used to predict software maintainability.Theycompared the Mamdani-based model with other machine learning approaches.The resultsshow that the Mamdani-based model is superior to all.},
	pages = {317--326},
	number = {6},
	journaltitle = {{IET} Software},
	author = {Ahmed, M.A. and Al-Jamimi, H.A.},
	date = {2013-12},
	keywords = {computational linguistics, {DP} industry, fuzzy logic, fuzzy logic-based transparent quality prediction model, fuzzy reasoning, imprecise linguistic knowledge, learning (artificial intelligence), machine learning approach, Mamdani-based model, Mamdani fuzzy inference engine, software company, software maintainability prediction, software maintenance, software quality, software quality parameter quantification},
	file = {IEEE Xplore Abstract Record:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/CZ8FD4VG/Ahmed and Al-Jamimi - 2013 - Machine learning approaches for predicting softwar.html:text/html;IEEE Xplore Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/TUXNRD7Z/Ahmed and Al-Jamimi - 2013 - Machine learning approaches for predicting softwar.pdf:application/pdf}
}

@online{vlatko_dangers_2015,
	title = {The dangers of spaghetti code},
	url = {https://jaxenter.com/the-dangers-of-spaghetti-code-117807.html},
	abstract = {What can happen when spaghetti code is relied upon to operate mission-critical systems? We look at the Toyota spaghetti code debacle and how it could be the bad habits of programmers inheriting code at the heart of the problem.},
	titleaddon = {{JAXenter}},
	author = {Vlatko, Natali},
	urldate = {2016-01-17},
	date = {2015-06-05},
	file = {Snapshot:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/T53Q35AB/the-dangers-of-spaghetti-code-117807.html:text/html;Snapshot:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/WIFMVJGX/The dangers of spaghetti code.html:text/html}
}

@article{chen_empirical_2009,
	title = {An empirical analysis of the impact of software development problem factors on software maintainability},
	volume = {82},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121208002793},
	doi = {10.1016/j.jss.2008.12.036},
	abstract = {Many problem factors in the software development phase affect the maintainability of the delivered software systems. Therefore, understanding software development problem factors can help in not only reducing the incidence of project failure but can also ensure software maintainability. This study focuses on those software development problem factors which may possibly affect software maintainability. Twenty-five problem factors were classified into five dimensions; a questionnaire was designed and 137 software projects were surveyed. A K-means cluster analysis was performed to classify the projects into three groups of low, medium and high maintainability projects. For projects which had a higher level of severity of problem factors, the influence on software maintainability becomes more obvious. The influence of software process improvement ({SPI}) on project problems and the associated software maintainability was also examined in this study. Results suggest that {SPI} can help reduce the level of severity of the documentation quality and process management problems, and is only likely to enhance software maintainability to a medium level. Finally, the top 10 list of higher-severity software development problem factors was identified, and implications were discussed.},
	pages = {981--992},
	number = {6},
	journaltitle = {Journal of Systems and Software},
	shortjournal = {Journal of Systems and Software},
	author = {Chen, Jie-Cherng and Huang, Sun-Jen},
	urldate = {2016-01-17},
	date = {2009-06},
	keywords = {Software development problem factors, Software maintainability, Software process improvement},
	file = {ScienceDirect Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/UBGXV6DK/Chen and Huang - 2009 - An empirical analysis of the impact of software de.pdf:application/pdf;ScienceDirect Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/DJHZA8PX/Chen and Huang - 2009 - An empirical analysis of the impact of software de.pdf:application/pdf;ScienceDirect Snapshot:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/N9RWFMHX/Chen and Huang - 2009 - An empirical analysis of the impact of software de.html:text/html;ScienceDirect Snapshot:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/IRGIND2G/S0164121208002793.html:text/html}
}

@article{glass_frequently_2001,
	title = {Frequently forgotten fundamental facts about software engineering},
	volume = {18},
	issn = {0740-7459},
	doi = {10.1109/MS.2001.922739},
	abstract = {Not Available},
	pages = {112--111},
	number = {3},
	journaltitle = {{IEEE} Software},
	author = {Glass, R.L.},
	date = {2001-05},
	keywords = {Costs, Degradation, Ergonomics, Logic testing, Processor scheduling, Productivity, Programming profession, Software engineering, Software testing, Software tools},
	annotate = {This paper offers an interesting analysis of the relationship between various attributes of software project such as Reliability, Maintainability, Efficiency and Complexity.},
	file = {IEEE Xplore Abstract Record:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/6FEBGUQ2/Glass - 2001 - Frequently forgotten fundamental facts about softw.html:text/html;IEEE Xplore Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/PESWHPX8/Glass - 2001 - Frequently forgotten fundamental facts about softw.pdf:application/pdf}
}

@article{dehaghani_which_2013,
	title = {Which Factors Affect Software Projects Maintenance Cost More?},
	volume = {21},
	issn = {0353-8109},
	url = {http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3610582/},
	doi = {10.5455/AIM.2012.21.63-66},
	abstract = {Introduction
The software industry has had significant progress in recent years. The entire life of software includes two phases: production and maintenance. Software maintenance cost is increasingly growing and estimates showed that about 90\% of software life cost is related to its maintenance phase. Extraction and considering the factors affecting the software maintenance cost help to estimate the cost and reduce it by controlling the factors.

Methods
In this study, the factors affecting software maintenance cost were determined then were ranked based on their priority and after that effective ways to reduce the maintenance costs were presented. This paper is a research study. 15 software related to health care centers information systems in Isfahan University of Medical Sciences and hospitals function were studied in the years 2010 to 2011.

Results and discussion
Among Medical software maintenance team members, 40 were selected as sample. After interviews with experts in this field, factors affecting maintenance cost were determined. In order to prioritize the factors derived by {AHP}, at first, measurement criteria (factors found) were appointed by members of the maintenance team and eventually were prioritized with the help of {EC} software. Based on the results of this study, 32 factors were obtained which were classified in six groups. “Project” was ranked the most effective feature in maintenance cost with the highest priority. By taking into account some major elements like careful feasibility of {IT} projects, full documentation and accompany the designers in the maintenance phase good results can be achieved to reduce maintenance costs and increase longevity of the software.},
	pages = {63--66},
	number = {1},
	journaltitle = {Acta Informatica Medica},
	shortjournal = {Acta Inform Med},
	author = {Dehaghani, Sayed Mehdi Hejazi and Hajrahimi, Nafiseh},
	urldate = {2016-01-17},
	date = {2013-03},
	pmid = {23572866},
	pmcid = {PMC3610582},
	annotate = {This paper analyses the effects of various factors such as Software Experience, Application understanding, Programming language etc on the maintenance costs of a project.},
	file = {PubMed Central Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/5IUSEBZV/Dehaghani and Hajrahimi - 2013 - Which Factors Affect Software Projects Maintenance.pdf:application/pdf}
}

@article{zhang_analysis_2000,
	title = {An analysis of factors affecting software reliability},
	volume = {50},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121299000758},
	doi = {10.1016/S0164-1212(99)00075-8},
	abstract = {This paper presents the findings of empirical research from 13 companies participating in software development to identify the factors that may impact software reliability. Thirty-two potential factors involved in every stage of the software development process are defined. The study uses a survey instrument to analyze these factors and identify factors that have significant impact on software reliability. The survey focuses on the perspective of the primary participants, managers, system engineers, programmers, testers and other people involved in software research or development teams. Two techniques such as the relative weight method and analysis of variance technique ({ANOVA}) have been used to analyze all factors and rank them in terms of their impact on software reliability. The research findings have important implications for further research and the practice of software development. For researchers, it points to improvement schemes of existing reliability modeling and factors that may be further verified and extended in subsequent research. For practitioners, it provides a general guide to the important aspects to consider in the whole software development process.},
	pages = {43--56},
	number = {1},
	journaltitle = {Journal of Systems and Software},
	shortjournal = {Journal of Systems and Software},
	author = {Zhang, Xuemei and Pham, Hoang},
	urldate = {2016-01-17},
	date = {2000-01},
	keywords = {Analysis of variance ({ANOVA}), Correlation analysis, Software reliability},
	annotate = {This paper presents 32 factors that affect maintainability \& reliability of software applications and offers analysis which finds that software complexity, programmer skill and testing effort to be some of the most significant factors that affect maintainability and reliability. },
	file = {ScienceDirect Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/WWTJ7BAE/Zhang and Pham - 2000 - An analysis of factors affecting software reliabil.pdf:application/pdf;ScienceDirect Snapshot:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/J4Q6CTM6/S0164121299000758.html:text/html}
}

@inproceedings{kajko-mattsson_long-term_2006,
	title = {Long-term Life Cycle Impact of Agile Methodologies},
	doi = {10.1109/ICSM.2006.34},
	abstract = {Dissatisfaction with heavyweight development approaches has lead to a proposal of agile methodologies. While heavyweight approaches are geared towards careful project planning, formalized quality assurance, and controlled and rigorous software development processes, the agile approaches focus on quick adaptation to change, and flexibility. Today, there are a number of different agile methods available, such as Scrum, Crystal, Adaptive Software Development, Feature Driven Development, and extreme programming. Although different, they share the same principles. Some of them are: (1) individuals and interactions over processes and tools, (2) working code over comprehensive documentation, (3) customer collaboration over contract negotiation, and (4) responding to change over following a plan. The proponents claim that agile methodologies lead to more effective and efficient development. The opponents, on the other hand, have stamped the agile approach as a "license to hack" or "cowboy", or "code-and-fix" method.},
	eventtitle = {22nd {IEEE} International Conference on Software Maintenance, 2006. {ICSM} '06},
	pages = {422--425},
	booktitle = {22nd {IEEE} International Conference on Software Maintenance, 2006. {ICSM} '06},
	author = {Kajko-Mattsson, M. and Lewis, G.A. and Siracusa, D. and Nelson, T. and Chapin, N. and Heydt, M. and Nocks, J. and Snee, H.},
	date = {2006-09},
	keywords = {Collaborative tools, Collaborative work, Computer hacking, Contracts, Documentation, Licenses, Process planning, Programming, Proposals, Quality assurance},
	annotate = {This paper offers unique perspective of analysis into Agile methodologies by summarising the positions of proponents and opponents of Agile who participated in a panel discussion.},
	file = {IEEE Xplore Abstract Record:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/RF5M7PFA/abs_all.html:text/html;IEEE Xplore Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/IXGEEXW8/Kajko-Mattsson et al. - 2006 - Long-term Life Cycle Impact of Agile Methodologies.pdf:application/pdf}
}

@article{razina_effects_2007,
	title = {Effects of Dependency Injection on Maintainability},
	url = {http://digitalcommons.calpoly.edu/csse_fac/34},
	pages = {7--12},
	journaltitle = {Proceedings of the 11th {IASTED} International Conference on Software Engineering and Applications: Cambridge, {MA}},
	author = {Razina, Ekaterina and Janzen, David},
	date = {2007-11-19},
	annotate = {This paper provides context into the relationship between testability and maintainability. A common factor with both attributes as mentioned is lower coupling of software components which eases testability and while also improving maintainability.},
	file = {"Effects of Dependency Injection on Maintainability" by Ekaterina Razina and David S. Janzen:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/FM4V5RGW/34.html:text/html}
}

@book{zhu_software_2005,
	location = {Jordan Hill, {GBR}},
	title = {Software Design Methodology : From Principles to Architectural Styles},
	isbn = {978-0-08-045496-2},
	url = {http://site.ebrary.com/lib/alltitles/docDetail.action?docID=10138509},
	shorttitle = {Software Design Methodology},
	publisher = {Butterworth-Heinemann},
	author = {Zhu, Hong},
	urldate = {2016-01-25},
	date = {2005},
	keywords = {Computer software., Software architecture.},
	file = {ebrary Snapshot:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/QS8UX4FP/detail.html:text/html}
}

@inproceedings{lee_reusability_2000,
	location = {New York, {NY}, {USA}},
	title = {Reusability and Maintainability Metrics for Object-oriented Software},
	isbn = {978-1-58113-250-2},
	url = {http://doi.acm.org/10.1145/1127716.1127737},
	doi = {10.1145/1127716.1127737},
	series = {{ACM}-{SE} 38},
	abstract = {In this paper, a quality model for object-oriented software and an automated metric tool, Reconfigurable Automated Metrics for Object-Oriented Software ({RAMOOS}) are proposed. The quality model is targeted at the maintainability and reusability aspects of software which can be effectively predicted from the source code. {RAMOOS} assists users in applying customized quality model during the development of software. In the beginning of adopting {RAMOOS}, a user may need to use his intuition to select or modify a system-recommended metric model to fit his specific software project needs. If the initial metrics do not meet the expectation, the user can retrive the saved intermediate results and perform further modification to the metric model. The verified model can then be applied to future similar projects.},
	pages = {88--94},
	booktitle = {Proceedings of the 38th Annual on Southeast Regional Conference},
	publisher = {{ACM}},
	author = {Lee, Young and Chang, Kai H.},
	urldate = {2016-01-25},
	date = {2000},
	file = {ACM Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/D54ZEGEK/Lee and Chang - 2000 - Reusability and Maintainability Metrics for Object.pdf:application/pdf}
}

@article{dubey_assessment_2011,
	title = {Assessment of Maintainability Metrics for Object-oriented Software System},
	volume = {36},
	issn = {0163-5948},
	url = {http://doi.acm.org/10.1145/2020976.2020983},
	doi = {10.1145/2020976.2020983},
	abstract = {Many organizations assess the maintainability of software systems before they are deployed. Object-oriented design has been shown to be a useful technique to develop and deliver quality software. Objectoriented metrics can be used to assess the maintainability of a software system. Various software metrics and models have been developed and described. This paper provides a review of this literature and the related state-of-the-art. It also proposes a maintainability model that is based on the analysis of the relationship between object-oriented metrics and maintainability.},
	pages = {1--7},
	number = {5},
	journaltitle = {{SIGSOFT} Softw. Eng. Notes},
	author = {Dubey, Sanjay Kumar and Rana, Ajay},
	urldate = {2016-01-25},
	date = {2011-09},
	keywords = {{CK} metric suite, Maintainability, metrics, object-oriented system, software},
	file = {ACM Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/NBDV2DVX/Dubey and Rana - 2011 - Assessment of Maintainability Metrics for Object-o.pdf:application/pdf}
}

@book{kan_metrics_2002,
	location = {Boston, {MA}, {USA}},
	edition = {2nd},
	title = {Metrics and Models in Software Quality Engineering},
	isbn = {978-0-201-72915-3},
	abstract = {From the Book:Looking at software engineering from a historical perspective, the 1960s and earlier could be viewed as the functional era, the 1970s the schedule era, the 1980s the cost era, and the 1990s and beyond the quality and efficiency era. In the 1960s, we learned how to exploit information technology to meet institutional needs and began to link software with the daily operations of institutions. In the 1970s, as the industry was characterized by massive schedule delays and cost overruns, the focus was on planning and control of software projects. Phase-based life-cycle models were introduced and analysis, like the mythical man-month, emerged. In the 1980s, hardware costs continued to decline, and information technology permeated every facet of our institutions and became available to individuals. As competition in the industry became keen and low-cost applications became widely implemented, the importance of productivity in software development increased significantly. Various cost models in software engineering were developed and used. In the late 1980s, the importance of quality was also recognized.The 1990s and beyond is certainly the quality era. With state-of-the-art technology now able to provide abundant functionality, customers demand high quality. Demand for quality is further intensified by the ever-increasing dependence of society on software. Billing errors, large-scale disrupted telephone services, and even missile failures during recent wars can all be traced to the issue of software quality. In this era, quality has been brought to the center of the software development process. From the standpoint of software vendors, quality is no longer an advantage factor inthe marketplace; it has become a necessary condition if a company is to compete successfully.Starting mid 1990s, two major factors emerged that proved to have unprecedented impact on not only software engineering but also on global business environments: business reengineering for efficiency and the Internet. Software development has to be more efficient and the quality level of the delivered products has to be high to meet requirements and to be successful. This is especially the case for mission-critical applications. The adverse impact of poor quality is much more significant and at a much wider scale; the quality “dikes” that software provides were never more important. These factors will continue to affect software engineering for many years to come during this new millennium.Measurement plays a critical role in effective and efficient software development, as well as provides the scientific basis for software engineering that makes it a true engineering discipline. This book describes the software quality engineering metrics and models: quality planning, process improvement and quality control, in-process quality management, product engineering (design and code complexity), reliability estimation and projection, and analysis of customer satisfaction data. Many measurement books take an encyclopedic approach, in which every possible software measurement is included, but this book confines its scope to the metrics and models of software quality. Areas such as cost estimation, productivity, staffing, and performance measurement, for which numerous publications exist, are not covered.In this edition, seven new chapters have been added, covering in-process metrics for software testing, object-oriented metrics, availability metrics, in-process quality assessment, software project assessment, process improvement dos and don’ts, and measuring software process improvement. The chapter that described the {AS}/400 software quality management system has been eliminated. For the original chapters, updates and revisions have been made throughout, and new sections, figures, and tables were added.Two of the new chapters are special contributions from two experts. This is a key feature of the new edition. The chapter on the dos and don’ts of software process improvement was contributed by Patrick O’Toole. Patrick brings to this book a perspective on process improvement that I share as a practitioner. That perspective is based on practical experience, is project-centric, and is aligned with the strategic business imperative of the organization. Patrick also brings humor to this otherwise serious subject, making the reading of the chapter so much enjoyable. The chapter on measuring software process improvement is a special contribution by Capers Jones. A pioneer in software metrics, productivity research, software quality control and software assessments, Capers’ work is well known nationally and internationally. His data-based and fact-based approach in software assessments and benchmarking studies is unparalleled. Based on experience and data from more than 10,000 projects, he brings to the readers a practical approach to software process improvement and the major quantitative findings related to software process improvement at the project and activity level. The chapter is a must read for software process professionals who are interested in quantitative measurements.Another new feature added to this edition is a set of recommendations for small teams that are starting to implement a metrics program, with minimum resources available. These recommendations are shown in the form of sidebar inserts in nine of the chapters. A number of examples in the book are based on small team projects and many methods and techniques are appropriate to large projects as well as small ones. This set of recommendations is from the perspective of small organizations using a small number of metrics, with the intent to effect improvement in their software development effort.This book is intended for use by software quality professionals; software project managers; software product managers; software development managers; software engineers; software product assurance personnel; and students in software engineering, management information systems, systems engineering, and quality engineering and management. For students, it is intended to provide a basis for a course at the upper-division undergraduate or graduate level. A number of software engineering, computer science, and quality engineering programs in the United States and overseas used the first edition of this book as a text.Themes of This {BookThis} book has several themes. First, balancing theory, techniques, and real-life examples, it provides practical guidelines in the practice of quality engineering in software development. Although equations and formulas are involved, the focus is on the understanding and applications of the metrics and models rather than mathematical derivations. Throughout the book, numerous real-life examples are used from the software development laboratory at {IBM} Rochester, Minnesota, home of the {AS}/400 and the {IBM} {eServer} {iSeries} computer systems, and from other companies in the software industry. {IBM} Rochester won the Malcolm Baldrige National Quality Award in 1990. A number of metrics described in this book were being used dating back to that time, and many have been developed and refined since then. All metrics are substantiated by ample implementation experience. {IBM} Rochester develops and delivers numerous different size and type projects every year, including very large and complex as well as small ones; and they range from firmware, to operating systems, to middleware, to applications.Second, I attempt to provide complete coverage of the type of metrics and models in software quality engineering. In addition to general discussions about metrics and techniques, this book categorizes and covers four types of models: (1) quality management models; (2) software reliability and projection models; (3) complexity metrics and models; and (4) customer-view metrics, measurements, and models. These metrics and models cover the entire software development process from high-level design to testing and maintenance, as well as all phases of reliability. Furthermore, although this book is not on total quality management ({TQM}), it is a major consideration in the coverage of metrics. The philosophy of {TQM} is the linking of product quality with customer satisfaction in order to achieve long-term success. {TQM} is the reason for including two chapters on the customer-view metrics and measurements—availability metrics and customer satisfaction—in addition to the many chapters on product and process metrics. In other discussions in the book, the customer’s perspective is also included where appropriate.Third, linking metrics and models to quality improvement strategies and improvement actions, we attempt to focus on using, not just describing, metrics. A framework for interpreting in-process metrics and assessing in-process quality status, the Effort/Outcome model, is presented. The direct link between a recommended quality strategy during development and the defect-removal model is shown. Examples of actions tying to specific metrics and analysis are given. Furthermore, to illustrate the metrics, many figures are used. This is a direct reflection of the fact that in a real-life project and quality management, a clear visual presentation often improves understanding and increases the effectiveness of the metrics.Fourth, following up on quality and process improvement at a more general level rather than on specific metric discussions, the continues with  chapters that discuss the in-process quality assessment process, a method for conducting software project assessments, practical advice on process improvement dos and don’ts, and quantitative analysis of software process improvement. The common thread underlying these chapters, and with other chapters on metrics and models, is practical experience with industry projects.Organization of This {BookThe} following list details what each chapter in this book addresses.Chapter 1, What Is Software Quality?, discusses the definition of quality and software quality. The customer’s role in the definition is highlighted. Quality attributes and their interrelationships are discussed. In the second part of the chapter covers the definition and framework of {TQM} and the customer’s view of quality, a key focus in this book.Chapter 2, Software Development Process Model, reviews various development process models that are used in the software industry. It briefly describes two methods of software process maturity assessment—the Carnegie Mellon University’s Software Engineering Institute’s ({SEI}) process Capability Maturity Model ({CMM}) and the Software Productivity Research ({SPR}) assessment method. It summarizes two bodies of quality management standards—the Malcolm Baldrige National Quality Award assessment discipline and {ISO} 9000. Chapter 3, Fundamentals in Measurement Theory, examines measurement theory fundamentals, which are very important for the practice of software measurement. The concept of operational definition and its importance in measurement are illustrated with an example. The level of measurement, some basic measures, and the concept of six sigma are discussed. The two key criteria of measurement quality, reliability and validity, and the related issue of measurement errors are examined and their importance is articulated. This chapter also provides a discussion on correlation and addresses the criteria needed to establish causality based on observational data. Chapter 4, Software Quality Metrics Overview, presents examples of quality metrics for the three categories of metrics associated with the software life-cycle: end-product, in-process, and maintenance. It describes the metrics programs of several large software companies and discusses software engineering data collection. Chapter 5, Applying the Seven Basic Quality Tools in Software Development, describes the application of the basic statistical tools for quality control, known as Ishikawa’s seven basic tools, in software development. The potentials and challenges of applying the control chart in software environments are discussed. In addition, a qualitative tool for brainstorming and for displaying complex cause-and-effect relationships—the relations diagram—is discussed. Chapter 6, Defect Removal Effectiveness, is the first of five chapters about the models and metrics that describe the quality dynamics of software development. Through two types of models, quality management models and software reliability and projection models, the quality of software development can be planned, engineered, managed, and projected. This chapter examines the central concept of defect-removal effectiveness, its measurements, and its role in quality planning.Chapter 7, The Rayleigh Model, describes the model and its implementation as a reliability and projection model. The Rayleigh Model’s use as a quality management model is discussed in Chapter 9.Chapter 8, Exponential Distribution and Reliability Growth Models, discusses the exponential distribution and the major software reliability growth models. These models, like the Rayleigh Model, are used for quality projection before the software is shipped to customers, just before development is complete. The models are also used to model the failure pattern or the defect arrival patterns in the field, for maintenance planning.Chapter 9, Quality Management Models, describes several quality management models that cover the entire development cycle. In-process metrics and reports that support the models are shown and discussed. A framework for interpreting in-process metrics and assessing in-process quality status—the Effort/Outcome model, is presented. Chapter 10, In-Process Metrics for Software Testing, is a continuation of Chapter 9; it focuses on the metrics for software testing. The Effort/Outcome model, as it applies to metrics during the testing phase, is elaborated. Candidate metrics for acceptance testing to evaluate vendor-developed software, and the central question of how do you know your product is good enough to ship, are also discussed.Chapter 11, Complexity Metrics and Models, discusses the third type of metrics and models in software engineering. While quality management models and reliability and projection models are for project management and quality management, the objective of the complexity metrics and models is for software engineers to be able to improve their design and implementation of software development. Chapter 12, Metrics and Lessons Learned for Object-Oriented Projects, covers design and complexity metrics, productivity metrics, quality and quality management metrics for object-oriented development, and lessons learned from the deployment and implementation of {OO} projects. The first section can be viewed as a continuation of the discussion on complexity metrics and models, while the other sections fall within the framework of quality and project management. Chapter 13, Availability Metrics, discusses system availability and outage metrics, and explores the relationships among availability, reliability, and the traditional defect-rate measurement. Availability metrics and customer satisfaction measurements are the fourth type of metrics and models—customer-oriented metrics. Chapter 14, Measuring and Analyzing Customer Satisfaction, discusses customer satisfaction data collection and measurements, and techniques and models for the analysis of customer satisfaction data. From Chapter 3 to this chapter, the entire spectrum of metrics and models is covered.Chapter 15, Conducting In-Process Quality Assessments, describes in-process quality assessments as an integrated element of good project quality management. Quality assessments are based on both quantitative indicators, such as those discussed in previous chapters, and qualitative information. Chapter 16, Conducting Software Project Assessments, takes the level of discussion yet another level higher; this chapter proposes a software project assessment method. The focus is at the project level and the discussion is from a practitioner’s perspective. Chapter 17, Dos and Don’ts of Software Process Improvement by Patrick O’Toole, offers practical advice for software process improvement professionals. It provides a link to the process maturity discussions in Chapter 2. Chapter 18, Measuring Software Process Improvement by Capers Jones, discusses the six stages of software process improvement. Based on a large body of empirical data, it examines the costs and effects of process improvement. It shows the results of quantitative analyses with regard to costs, time, schedule, productivity, and quality. It provides a link to the process maturity discussions in Chapter 2.Chapter 19, Concluding Remarks, provides several observations with regard to software measurement in general and software quality metrics and models in particular, and it offers a perspective on the future of software engineering measurement.Suggested Ways to Read This {BookThe} chapters of this book are organized for reading from beginning to end. Concepts and discussions in earlier chapters are referenced in later chapters. At the same time, each chapter addresses a separate topic and chapters within some groups are more closely coupled to each other than to others. Some readers may choose to read specific topics or decide on different starting points. For example, those who are not interested in quality definitions, process models, and measurement fundamentals discussions, can start with Chapter 4, Software Quality Metrics Overview. Those who intend to immediately get to the central topics of defect removals and metrics and models for quality planning, management and projection, can start with Chapter 6, Defect Removal Effectiveness. In general, I recommend that you read the chapters together in groups, as follows.Chapters 1 to 3Chapter 4Chapter 5 Chapters 6 to 10Chapters 11 and 12Chapters 13 and 14Chapters 15 to 18Chapter 19},
	publisher = {Addison-Wesley Longman Publishing Co., Inc.},
	author = {Kan, Stephen H.},
	date = {2002}
}

@article{jeet_comparative_2012,
	title = {A Comparative Study of Bayesian and Fuzzy Approach to Assess and Predict Maintainability of the Software Using Activity-based Quality Model},
	volume = {37},
	issn = {0163-5948},
	url = {http://doi.acm.org/10.1145/180921.2180935},
	doi = {10.1145/180921.2180935},
	abstract = {Quality is considered as one of the most important aspects responsible for the success of the software. The developers as well as the end users of the software have accepted maintainability as a significant characteristic due to its economic implications. Several subjective techniques have been developed in research to assess and predict maintainability but all have been unsuccessful to do it practically and most of them even fail to define it appropriately. The activity-based quality model is one of the techniques that have been found to be successful in defining maintainability. This model assesses maintainability in terms of average efforts required to maintain software but lacks quantitative aspect that has been further added by using Bayesian Network. In this paper, a comparison of the Bayesian approach and Fuzzy approach to deal with this model quantitatively has been done wherein; Fuzzy approach has been found to be better than Bayesian},
	pages = {1--9},
	number = {3},
	journaltitle = {{SIGSOFT} Softw. Eng. Notes},
	author = {Jeet, Kawal and Dhir, Renu and Verma, Harsh},
	urldate = {2016-01-25},
	date = {2012-05},
	keywords = {activity-based quality model, appropriateness of comments, extent of modules, Maintainability, regularity of implementation, software quality},
	file = {ACM Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/CZSEXWRX/Jeet et al. - 2012 - A Comparative Study of Bayesian and Fuzzy Approach.pdf:application/pdf}
}

@book{wallerstorfer_improving_2012,
	title = {Improving Maintainability with Scrum: How Scrum Affects Code Maintainability},
	isbn = {978-3-639-40227-8},
	shorttitle = {Improving Maintainability with Scrum},
	abstract = {This thesis aims to provide additional insight into the effect of different development strategies on the maintainability of code. Maintainability is defined as the ease with which a software can be modified. Throughout a software development project a lot of time is spent on maintenance. Therefore code that is easy to maintain is desireable. To be able to detect differences between development strategies a case study with a development team of an Austrian company was conducted. The team changed its development strategy from the waterfall model to Scrum. The development of the code maintainability was analyzed when using the waterfall model and when using Scrum as development strategy. In order to quantifiy the maintainability of code the common approach of using static code analysis is used. Based on results in literature a set of software metrics was used to assess the code maintainbility. The results indicate that Scrum does not decrease the code maintainability as much as the waterfall model over time. Scrum does a better job in preserving the level of code maintainability than the waterfall model. The possible reasons for this are discussed in the thesis.},
	publisher = {{AV} Akademikerverlag},
	author = {Wallerstorfer, Dirk},
	date = {2012}
}

@inproceedings{sutherland_distributed_2007,
	title = {Distributed Scrum: Agile Project Management with Outsourced Development Teams},
	doi = {10.1109/HICSS.2007.180},
	shorttitle = {Distributed Scrum},
	abstract = {Agile project management with Scrum derives from best business practices in companies like Fuji-Xerox, Honda, Canon, and Toyota. Toyota routinely achieves four times the productivity and 12 times the quality of competitors. Can Scrum do the same for globally distributed teams? Two agile companies, {SirsiDynix} and {StarSoft} development laboratories achieved comparable performance developing a Java application with over 1,000,000 lines of code. During 2005, a distributed team of 56 Scrum developers working from Provo, Utah; Waterloo, Canada; and St. Petersburg, Russia, delivered 671,688 lines of production Java code. At 15.3 function points per developer/month, this is the most productive Java project ever documented. {SirsiDynix} best practices are similar to those observed on distributed Scrum teams at {IDX} Systems, radically different than those promoted by {PMBOK}, and counterintuitive to practices advocated by the Scrum Alliance. This paper analyzes and recommends best practices for globally distributed agile teams},
	eventtitle = {40th Annual Hawaii International Conference on System Sciences, 2007. {HICSS} 2007},
	pages = {274a--274a},
	booktitle = {40th Annual Hawaii International Conference on System Sciences, 2007. {HICSS} 2007},
	author = {Sutherland, J. and Viktorov, A. and Blount, J. and Puntikov, N.},
	date = {2007-01},
	keywords = {agile project management, Best practices, Companies, Computer architecture, distributed Scrum, Java, Java application, Object oriented modeling, outsourced development team, outsourcing, Productivity, Programming, program testing, project management, software development management, Software systems, team working, Uncertainty},
	file = {IEEE Xplore Abstract Record:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/PW6XZG3A/abs_all.html:text/html;IEEE Xplore Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/RD3A8Q5C/Sutherland et al. - 2007 - Distributed Scrum Agile Project Management with O.pdf:application/pdf}
}

@article{genero_building_2007,
	title = {Building measure-based prediction models for {UML} class diagram maintainability},
	volume = {12},
	issn = {1382-3256, 1573-7616},
	url = {http://link.springer.com.offcampus.lib.washington.edu/article/10.1007/s10664-007-9038-4},
	doi = {10.1007/s10664-007-9038-4},
	abstract = {The usefulness of measures for the analysis and design of object oriented ({OO}) software is increasingly being recognized in the field of software engineering research. In particular, recognition of the need for early indicators of external quality attributes is increasing. We investigate through experimentation whether a collection of {UML} class diagram measures could be good predictors of two main subcharacteristics of the maintainability of class diagrams: understandability and modifiability. Results obtained from a controlled experiment and a replica support the idea that useful prediction models for class diagrams understandability and modifiability can be built on the basis of early measures, in particular, measures that capture structural complexity through associations and generalizations. Moreover, these measures seem to be correlated with the subjective perception of the subjects about the complexity of the diagrams. This fact shows, to some extent, that the objective measures capture the same aspects as the subjective ones. However, despite our encouraging findings, further empirical studies, especially using data taken from real projects performed in industrial settings, are needed. Such further study will yield a comprehensive body of knowledge and experience about building prediction models for understandability and modifiability.},
	pages = {517--549},
	number = {5},
	journaltitle = {Empirical Software Engineering},
	shortjournal = {Empir Software Eng},
	author = {Genero, Marcela and Manso, Esperanza and Visaggio, Aaron and Canfora, Gerardo and Piattini, Mario},
	urldate = {2016-01-25},
	date = {2007-03-21},
	langid = {english},
	keywords = {Class diagrams, Controlled experiments, Empirical validation, Maintainability, Measures, Modifiability, Prediction model, Programming Languages, Compilers, Interpreters, Size, Software Engineering/Programming and Operating Systems, Structural complexity, {UML}, Understandability},
	file = {Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/3M9ADKBK/Genero et al. - 2007 - Building measure-based prediction models for UML c.pdf:application/pdf;Snapshot:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/9D4IPBPM/s10664-007-9038-4.html:text/html}
}

@inproceedings{riaz_systematic_2009,
	location = {Washington, {DC}, {USA}},
	title = {A Systematic Review of Software Maintainability Prediction and Metrics},
	isbn = {978-1-4244-4842-5},
	url = {http://dx.doi.org/10.1109/ESEM.2009.5314233},
	doi = {10.1109/ESEM.2009.5314233},
	series = {{ESEM} '09},
	abstract = {This paper presents the results of a systematic review conducted to collect evidence on software maintainability prediction and metrics. The study was targeted at the software quality attribute of maintainability as opposed to the process of software maintenance. The evidence was gathered from the selected studies against a set of meaningful and focused questions. 710 studies were initially retrieved; however of these only 15 studies were selected; their quality was assessed; data extraction was performed; and data was synthesized against the research questions. Our results suggest that there is little evidence on the effectiveness of software maintainability prediction techniques and models.},
	pages = {367--377},
	booktitle = {Proceedings of the 2009 3rd International Symposium on Empirical Software Engineering and Measurement},
	publisher = {{IEEE} Computer Society},
	author = {Riaz, Mehwish and Mendes, Emilia and Tempero, Ewan},
	urldate = {2016-01-25},
	date = {2009},
	file = {ACM Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/TB5KZETJ/Riaz et al. - 2009 - A Systematic Review of Software Maintainability Pr.pdf:application/pdf}
}

@inproceedings{hayes_maintainability_2005,
	title = {Maintainability prediction: a regression analysis of measures of evolving systems},
	doi = {10.1109/ICSM.2005.59},
	shorttitle = {Maintainability prediction},
	abstract = {In order to build predictors of the maintainability of evolving software, we first need a means for measuring maintainability as well as a training set of software modules for which the actual maintainability is known. This paper describes our success at building such a predictor. Numerous candidate measures for maintainability were examined, including a new compound measure. Two datasets were evaluated and used to build a maintainability predictor. The resulting model, Maintainability Prediction Model ({MainPredMo}), was validated against three held-out datasets. We found that the model possesses predictive accuracy of 83\% (accurately predicts the maintainability of 83\% of the modules). A variant of {MainPredMo}, also with accuracy of 83\%, is offered for interested researchers.},
	eventtitle = {Proceedings of the 21st {IEEE} International Conference on Software Maintenance, 2005. {ICSM}'05},
	pages = {601--604},
	booktitle = {Proceedings of the 21st {IEEE} International Conference on Software Maintenance, 2005. {ICSM}'05},
	author = {Hayes, J.H. and Zhao, L.},
	date = {2005-09},
	keywords = {Accuracy, candidate measure, Computer science, Error correction, Lab-on-a-chip, {MainPredMo}, maintainability prediction model, Performance analysis, Predictive models, {REGRESSION} analysis, software maintenance, Software measurement, software metrics, software modules, software prototyping, Software systems, software systems evolution, training set},
	file = {IEEE Xplore Abstract Record:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/B34IVZ9A/abs_all.html:text/html;IEEE Xplore Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/E2FRKUFC/Hayes and Zhao - 2005 - Maintainability prediction a regression analysis .pdf:application/pdf}
}

@article{balsamo_model-based_2004,
	title = {Model-based performance prediction in software development: a survey},
	volume = {30},
	issn = {0098-5589},
	doi = {10.1109/TSE.2004.9},
	shorttitle = {Model-based performance prediction in software development},
	abstract = {Over the last decade, a lot of research has been directed toward integrating performance analysis into the software development process. Traditional software development methods focus on software correctness, introducing performance issues later in the development process. This approach does not take into account the fact that performance problems may require considerable changes in design, for example, at the software architecture level, or even worse at the requirement analysis level. Several approaches were proposed in order to address early software performance analysis. Although some of them have been successfully applied, we are still far from seeing performance analysis integrated into ordinary software development. In this paper, we present a comprehensive review of recent research in the field of model-based performance prediction at software development time in order to assess the maturity of the field and point out promising research directions.},
	pages = {295--310},
	number = {5},
	journaltitle = {{IEEE} Transactions on Software Engineering},
	author = {Balsamo, S. and di Marco, A. and Inverardi, P. and Simeoni, M.},
	date = {2004-05},
	keywords = {65, Automation, Availability, formal verification, integrated environments., model-based performance prediction, Performance analysis, performance modeling and prediction, Predictive models, Programming, requirement analysis level, Runtime, Software architecture, software architecture level, software development process, Software performance, software performance analysis, software performance evaluation, Software process improvement, Software systems, software verification, System software},
	file = {IEEE Xplore Abstract Record:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/DZ7J7XU2/abs_all.html:text/html;IEEE Xplore Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/8KFBCPUE/Balsamo et al. - 2004 - Model-based performance prediction in software dev.pdf:application/pdf}
}

@inproceedings{genero_building_2003,
	title = {Building {UML} class diagram maintainability prediction models based on early metrics},
	doi = {10.1109/METRIC.2003.1232473},
	abstract = {The fact that the usage of metrics in the analysis and design of object oriented ({OO}) software can help designers make better decisions is gaining relevance in software measurement arena. Moreover, the necessity of having early indicators of external quality attributes, such as maintainability, based on early metrics is growing. In addition to this, the aim is to show how early metrics which measure internal attributes, such as structural complexity and size of {UML} class diagrams, can be used as early class diagram maintainability indicators. For this purpose, we present a controlled experiment and its replication, which we carried out to gather the empirical data, which in turn is the basis of the current study. From the results obtained, it seems that there is a reasonable chance that useful class diagram maintainability models could be built based on early metrics. Despite this fact, more empirical studies, especially using data taken form real projects performed in industrial settings, are needed in order to obtain a comprehensive body of knowledge and experience.},
	eventtitle = {Software Metrics Symposium, 2003. Proceedings. Ninth International},
	pages = {263--275},
	booktitle = {Software Metrics Symposium, 2003. Proceedings. Ninth International},
	author = {Genero, M. and Piattini, M. and Manso, E. and Cantone, G.},
	date = {2003-09},
	keywords = {class diagram size, Computer science, data description, empirical data validation, Object oriented modeling, object-oriented programming, object oriented software metrics, Phase measurement, Predictive models, Programming, program verification, Size measurement, Software design, software maintenance, Software measurement, software metrics, software quality, Software reliability, specification languages, Structural complexity, {UML} class diagram maintainability prediction model, Unified modeling language},
	file = {IEEE Xplore Abstract Record:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/VMZDPVCI/abs_all.html:text/html;IEEE Xplore Full Text PDF:/home/gautam/.mozilla/firefox/mwad0hks.default/zotero/storage/M6G8QQP7/Genero et al. - 2003 - Building UML class diagram maintainability predict.pdf:application/pdf}
}

@article{coleman_using_1994,
	title = {Using Metrics to Evaluate Software System Maintainability},
	volume = {27},
	issn = {0018-9162},
	url = {http://dx.doi.org/10.1109/2.303623},
	doi = {10.1109/2.303623},
	abstract = {Software metrics have been much criticized in the last few years, sometimes justly but more often unjustly, because critics misunderstand the intent behind the technology. Software complexity metrics, for example, rarely measure the "inherent complexity" embedded in software systems, but they do a very good job of comparing the relative complexity of one portion of a system with another. In essence, they are good modeling tools. Whether they are also good measuring tools depends on how consistently and appropriately they are applied.},
	pages = {44--49},
	number = {8},
	journaltitle = {Computer},
	author = {Coleman, Don and Ash, Dan and Lowther, Bruce and Oman, Paul},
	urldate = {2016-01-25},
	date = {1994-08}
}